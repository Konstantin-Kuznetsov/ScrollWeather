
### ScrollWeather
> **Использованные в проекте библиотеки:** 

> - Retrofit2
> - GSON
> - Picasso
> - Dagger 2.11 (но не использовал Custom scopes, Subcomponents и dagger-android)
> - Google maps
> - Butterknife
> - UI - ConstraintLayout, CardView, RecyclerView, NavigationView, PreferenceFragment(экран пользовательских настроек)

Структурный паттерн - MVP
----------
Структура - одна `Activity` и по фрагменту на каждый экран(карта, добавление городов в список и т.д).  `Activity` содержит только `NavigationView` и `FrameLayout` для смены фрагментов.

![Структурная схема проекта](https://user-images.githubusercontent.com/18750579/32222119-14e5e886-be49-11e7-8c9f-e272ccab1a70.png)

Model
----------

 -	В слое данных реализован паттерн “репозиторий” - так, как я себе это понял из статей. Класс `DataManager` абстрагирует презентеры от непосредственных источников и хранилищ данных через интерфейс. На каждый тип запроса создан метод в `DataManager`, т.е запрос погоды по названию города, запрос по ID города, запрос по текущему местоположению. Пока типов запросов относительно немного – все ок, если это все будет разрастаться, видимо, нужно будет делать какую-то обертку над `DataManager`. 
 -	Класс `RESTDataProvider`, используя `Retrofit` асинхронно забирает данные с погодного сервера(если сеть вообще доступна). Ответ приходит в JSON и с помощью конвертера `GSON` парсится, сохраняется локально и отображается в UI. В обратную сторону все то же самое- читается строка и преобразуется в необходимый POJO  класс.
 -	LocalDataProvider читает из Shared Preferences пользовательские настройки(список сохраненных городов, язык, метрическую систему и т.д) и погодные данные. Все сохраняется просто в String, опять же с помощью GSON. Если сеть недоступна- данные сразу отдаются из Shared Preferences, без запроса в сеть(последние сохраненные).

View
----------
- Все View сделаны максимально пассивными – в них `Dagger` инжектит `presenter`, в них обрабатываются события ЖЦ фрагмента, а также прикрепляется (`relevantPresenter.attachView(this)`) и открепляется (`relevantPresenter.detachView()`) от  презентера. Все остальное делает презентер, хранящий `WeakReference` на фрагмент. В общем, View только передает пользовательские события Presenter, больше ничего.

Presenter
----------
Презентеры переживают поворот экрана, обрабатывают пользовательские события, обращаются к `DataManager` за данными. Ссылки на view инжектятся `Butterknife` тоже внутри презентера и обновляются данными тоже из презентера.


**Обзор основных экранов**
----------

Основной экран с прогнозами:
----------
![forecasts-screen](https://user-images.githubusercontent.com/18750579/32272311-9d36190c-bf0e-11e7-95f1-0a92f304a714.gif)

 Основной экран с максимально актуальными данными - либо грузит новые прогнозы по сети, либо достает последнее закэшированное. Два `RecyclerView` с прогнозом по дням и по трехчасовым интервалам, а так же в верхней части данные на текущий момент. 
 Если в списке городов не добавлено ничего, то пользователь получит предложение добавить хотя бы один и начать работу с программой, в противном случае загружается первый из списка сохраненных. Скрытие и показ views сделано через добавление элементов в список через `@BindViews` и массовое изменение признака видимости через `ButterKnife.Setter`.
 Переключение между городами зациклено, при нажатии стрелки "следующий" на последнем городе из списка- покажется первый, в обратную сторону то же самое- "предыдущий" на первом, загрузит данные из последнего. 
 Для `RecyclerView` сделан эффект "долистывания", т.е докрутки списка до полной видимости крайнего левого элемента с помощью `LinearSnapHelper` ([подробнее](https://developer.android.com/reference/android/support/v7/widget/LinearSnapHelper.html)). Что конкретно сделано - можно посмотреть в классе `HorizontalStartSnapHelper` в проекте. Только в несколько кастомизированном виде, по умолчанию долистывание "центрирует" элементы, я же переопределил `calculateDistanceToFinalSnap` и `findSnapView` для достижения необходимого поведения.
 В прокручиваемом списке с трехчасовыми прогнозами просчитывается интервал в часах(до целых) от текущего времени, например прогноз +15С (+3ч), означает прогноз на 3 часа от текущего момента.
 Иконки грузятся с сервера openweathermap.org, они доступны только в одном размере, по крайней мере с бесплатным аккаунтом, поэтому при растягивании смотрятся ужасно, но тут хотелось просто показать асинхронную подгрузку картинки из сети, не более. Вообще все отображаемые данные берутся из получаемого JSON, причем не все, всемя восхода-заката, видимость и еще многое другое я решил не отображать, но в POJO они все равно есть, если нужно будет - можно быстро добавить.
 Все спецсимволы - знаки градусов, символы Фаренгейта, Цельсия, часы(ч), все служебные сообщения, надписи и прочее - достается из strings.xml, при необходимости локализации приложения - можно будет быстрее это сделать, переведя строки оттуда.
 
 Экран с картой:
----------
 ![map-screen](https://user-images.githubusercontent.com/18750579/32274419-cbf9b4d4-bf17-11e7-916c-0232fb92eabc.gif)
 На карте отображаются маркеры добавленных пользователем в список городов. При клике на маркер- появляется InfoWindow с погодой в соответствующем городе. Картинка грузится точе с помощью Picasso. Так как это InfoWindow не что иное как картинка поверх карты, то для обновления чего-либо на нем, приходится скрыть и показать опять, уже с новыми данными, никакого доступа к view на этом окошке просто нет. В данном случае перерисовка делается в коллбэке picasso по окончании загрузки. В InfoWindowRefresher(marker) передается, собственно, маркер, который нужно будет обновить. Если бы загрузка шла долго- пользователь успел бы увидеть картинку-заглушку на первом появившемся окне, но, в принципе, картинка маленькая, все быстро и приемлемо отображается.
 ClusterManager управляет кластерами с маркерами городов. Никаких особых кастомизаций тут не проводилось, но, можно поменять внешний вид кластера, например. Или поменять поведение по клику на кластер, сейчас просто камера плавно наезжает на область, содержащую маркеры из этого кластера.
 Маркеры тоже никак не кастомизировались, только по клику появляется MarkerInfoWindow (custom_info_window.xml) с некоторыми данными и картинкой. Клик по InfoWindow можно как-то обрабатывать, перебрасывать на страницу с подробным прогнозом или что-то подобное, но тут я ничего не сделал.
 
 ```java
googleMap.setOnInfoWindowClickListener(new GoogleMap.OnInfoWindowClickListener() {
 @Override
 public void onInfoWindowClick(Marker marker) {
  if (chosenMarker instanceof CityMarker) {
   // что-то делаем
  }
 }
}); 
```

Экран добавления/удаления городов:
----------     
![edit-screen](https://user-images.githubusercontent.com/18750579/32275434-4434ceee-bf1c-11e7-98be-6856ad64556b.gif)

![edit2-screen](https://user-images.githubusercontent.com/18750579/32275447-4c8f8002-bf1c-11e7-9644-bc22296c98f8.gif)

Для добавления городов используется кастомизированный AppCompatAutoCompleteTextView. 
Параметр android:completionThreshold = "2", при вводе двух и более букв названия города, асинхронно запрашивается список примерно подходящих по названию. Можно переключить на точное совпадение поискового запроса в настройках приложения, openweathermap позволяет искать и так и так. Полученный от сервера по api список городов формирует выпадающий список, причем каждый отдельный элемент тоже слегка изменен- загружается иконка погоды, код страны и т.д для удобства использования. И ради эксперимента, конечно тоже.

`RecyclerView` со списком уже добавленных городов реализует поведение swipe-to-dismiss и drag & drop. Это очень удобно сделать, используя `ItemTouchHelper`([подробнее](https://developer.android.com/reference/android/support/v7/widget/helper/ItemTouchHelper.html)). 
`ItemTouchHelper` имеет удобный `ItemTouchHelper.SimpleCallback`, необходимо переопределить `onMove()`, `onSwiped()`, `onSelectedChanged()` по желанию, `clearView()`. После этого просто устанавливается на `RecyclerView`, который должен реализовывать такое поведение(`itemTouchHelper.attachToRecyclerView(relevantRecycler);`).

Экран настроек:
----------
![settings-screen](https://user-images.githubusercontent.com/18750579/32276331-c60cc96e-bf1f-11e7-9fa1-fc7e299b0826.gif)

```java
public class SettingsFragment extends PreferenceFragmentCompat implements SharedPreferences.OnSharedPreferenceChangeListener { ... }
```

Экран с настройками реализован через предлагаемый PreferenceFragmentCompat, настройки читаются и пишутся в SharedPreferences.
Все настройки прописаны в preferences.xml. При изменении настроек, пользователь оповещается через Snackbar - что и как изменено.
В настройках расположены все настройки, которые позволяет передавать в запросе http://api.openweathermap.org, количество дней в ответе, система измерений, язык и т.д.
