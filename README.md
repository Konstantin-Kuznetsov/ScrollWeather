
### ScrollWeather
> **Использованные в проекте библиотеки:** 

> - Retrofit2
> - GSON
> - Picasso
> - Dagger 2.11 (но не использовал Custom scopes, Subcomponents и dagger-android)
> - Google maps
> - Butterknife
> - UI - ConstraintLayout, CardView, RecyclerView, NavigationView, PreferenceFragment(экран пользовательских настроек)

Структурный паттерн - MVP
----------
Структура - одна `Activity` и по фрагменту на каждый экран(карта, добавление городов в список и т.д).  `Activity` содержит только `NavigationView` и `FrameLayout` для смены фрагментов.

![Структурная схема проекта](https://user-images.githubusercontent.com/18750579/32222119-14e5e886-be49-11e7-8c9f-e272ccab1a70.png)

Model
----------

 -	В слое данных реализован паттерн “репозиторий” - так, как я себе это понял из статей. Класс `DataManager` абстрагирует презентеры от непосредственных источников и хранилищ данных через интерфейс. На каждый тип запроса создан метод в `DataManager`, т.е запрос погоды по названию города, запрос по ID города, запрос по текущему местоположению. Пока типов запросов относительно немного – все ок, если это все будет разрастаться, видимо, нужно будет делать какую-то обертку над `DataManager`. 
 -	Класс `RESTDataProvider`, используя `Retrofit` асинхронно забирает данные с погодного сервера(если сеть вообще доступна). Ответ приходит в JSON и с помощью конвертера `GSON` парсится, сохраняется локально и отображается в UI. В обратную сторону все то же самое- читается строка и преобразуется в необходимый POJO  класс.
 -	LocalDataProvider читает из Shared Preferences пользовательские настройки(список сохраненных городов, язык, метрическую систему и т.д) и погодные данные. Все сохраняется просто в String, опять же с помощью GSON. Если сеть недоступна- данные сразу отдаются из Shared Preferences, без запроса в сеть(последние сохраненные).

View
----------
- Все View сделаны максимально пассивными – в них `Dagger` инжектит `presenter`, в них обрабатываются события ЖЦ фрагмента, а также прикрепляется (`relevantPresenter.attachView(this)`) и открепляется (`relevantPresenter.detachView()`) от  презентера. Все остальное делает презентер, хранящий `WeakReference` на фрагмент. В общем, View только передает пользовательские события Presenter, больше ничего.

Presenter
----------
Презентеры переживают поворот экрана, обрабатывают пользовательские события, обращаются к DataManager за данными. Ссылки на view инжектятся Butterknife’ом тоже внутри презентера и обновляются данными тоже из презентера.



